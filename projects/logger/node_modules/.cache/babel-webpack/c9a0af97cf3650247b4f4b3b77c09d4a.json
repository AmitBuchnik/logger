{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { asyncScheduler } from 'rxjs';\nimport { LogPublishersService } from './log.publishers.service';\nimport { Config } from '../models/config.model';\nimport { LogLevel } from '../enums/log-levels.enum';\nimport { LogEntry } from '../models/log-entry.model';\nlet LogService = class LogService {\n  constructor(config, publishersService) {\n    this.config = config;\n    this.publishersService = publishersService; // Set publishers\n\n    this.publishers = this.publishersService.publishers;\n  }\n\n  debug(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.Debug, optionalParams);\n  }\n\n  info(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.Info, optionalParams);\n  }\n\n  warn(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.Warn, optionalParams);\n  }\n\n  error(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.Error, optionalParams);\n  }\n\n  fatal(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.Fatal, optionalParams);\n  }\n\n  log(msg, ...optionalParams) {\n    this.writeToLog(msg, LogLevel.All, optionalParams);\n  }\n\n  writeToLog(msg, level, params) {\n    var _a, _b;\n\n    if (this.shouldLog(level)) {\n      let entry = new LogEntry();\n      entry.message = msg;\n      entry.level = level;\n      entry.extraInfo = params;\n      entry.logWithDate = this.config.logWithDate;\n      entry.logStackTrace = this.config.logStackTrace;\n      entry.timestampFormat = (_b = (_a = this.config.messageFormat) === null || _a === void 0 ? void 0 : _a.timestampFormat) !== null && _b !== void 0 ? _b : '';\n\n      for (let logger of this.publishers) {\n        if (this.config.useQueue) {\n          const task = () => logger.log(entry);\n\n          asyncScheduler.schedule(task, this.config.flushTiming);\n        } else {\n          logger.log(entry);\n        }\n      }\n    }\n  }\n\n  shouldLog(level) {\n    var _a, _b;\n\n    let ret = false;\n\n    if (((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.environment) === null || _b === void 0 ? void 0 : _b.production) && (level >= this.config.level && level !== LogLevel.Off || this.config.level === LogLevel.All)) {\n      ret = true;\n    }\n\n    return ret;\n  }\n\n};\n\nLogService.ctorParameters = () => [{\n  type: Config\n}, {\n  type: LogPublishersService\n}];\n\nLogService = __decorate([Injectable({\n  providedIn: 'root'\n})], LogService);\nexport { LogService };","map":{"version":3,"sources":["C:\\Amit\\e-square\\projects\\logger\\src\\lib\\services\\log.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { asyncScheduler } from 'rxjs';\n\nimport { LogPublisher } from '../logger-types/log.publisher';\nimport { LogPublishersService } from './log.publishers.service';\nimport { Config } from '../models/config.model';\nimport { LogLevel } from '../enums/log-levels.enum';\nimport { LogEntry } from '../models/log-entry.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LogService {\n\n  publishers: LogPublisher[];\n\n  constructor(public config: Config,\n    private publishersService: LogPublishersService) {\n    // Set publishers\n    this.publishers = this.publishersService.publishers;\n  }\n\n  debug(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.Debug, optionalParams);\n  }\n\n  info(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.Info, optionalParams);\n  }\n\n  warn(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.Warn, optionalParams);\n  }\n\n  error(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.Error, optionalParams);\n  }\n\n  fatal(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.Fatal, optionalParams);\n  }\n\n  log(msg: string, ...optionalParams: any[]) {\n    this.writeToLog(msg, LogLevel.All, optionalParams);\n  }\n\n  private writeToLog(msg: string, level: LogLevel, params: any[]) {\n    if (this.shouldLog(level)) {\n      let entry = new LogEntry();\n      entry.message = msg;\n      entry.level = level;\n      entry.extraInfo = params;\n      entry.logWithDate = this.config.logWithDate;\n      entry.logStackTrace = this.config.logStackTrace;\n      entry.timestampFormat = this.config.messageFormat?.timestampFormat ?? '';\n\n      for (let logger of this.publishers) {\n        if (this.config.useQueue) {\n          const task = () => logger.log(entry);\n          asyncScheduler.schedule(task, this.config.flushTiming);\n        } else {\n          logger.log(entry);\n        }\n      }\n    }\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    let ret = false;\n    if (this.config?.environment?.production &&\n      ((level >= this.config.level && level !== LogLevel.Off) || this.config.level === LogLevel.All)) {\n      ret = true;\n    }\n    return ret;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}